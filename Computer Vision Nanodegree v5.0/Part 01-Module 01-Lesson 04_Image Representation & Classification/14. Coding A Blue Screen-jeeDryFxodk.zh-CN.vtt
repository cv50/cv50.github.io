WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.810
我们来在 Python 里编写一段代码吧 用这段代码来进行简单的蓝幕颜色选择

00:00:03.810 --> 00:00:07.617
本课我们要用一个新库 叫做 OpenCV

00:00:07.617 --> 00:00:09.240
该库常用于计算机视觉应用

00:00:09.240 --> 00:00:13.940
能帮我们开发自定义应用程序

00:00:13.939 --> 00:00:17.535
我们有张以蓝幕为背景的披萨图

00:00:17.535 --> 00:00:19.495
我们要先把这个蓝色区域识别出来

00:00:19.495 --> 00:00:23.420
然后再将它替换成我们选择的背景图片

00:00:23.420 --> 00:00:26.490
这是我们的 Python notebook

00:00:26.489 --> 00:00:30.254
第一步 导入要用的库 我们整个课程都会用到这些库

00:00:30.254 --> 00:00:35.310
从 matplotlib 导入 pyplot 来绘图

00:00:35.310 --> 00:00:41.219
至于图像处理 则用 numpy 和计算机视觉库 OpenCV 该库名为 cv2

00:00:41.219 --> 00:00:46.570
接着 用 cv2.imread 来读取披萨图

00:00:46.570 --> 00:00:49.109
图像名为 pizza_ bluescreen.jpg

00:00:49.109 --> 00:00:54.109
该图所在目录与这个 notebook 一样 都是在名为 “images” 的文件夹里

00:00:54.109 --> 00:00:57.899
读取完毕后 你可能想输出一些图像信息

00:00:57.899 --> 00:01:01.784
在处理任何图像之前 先看看这些信息总是很有帮助的

00:01:01.784 --> 00:01:06.352
所以我要输出数据的类型 我想这应该是个二维数组

00:01:06.352 --> 00:01:09.584
也就是一个储存着像素值的网格或矩阵

00:01:09.584 --> 00:01:14.179
我还要输出形状 以便了解图像的维数

00:01:14.180 --> 00:01:17.925
运行这段代码 我们就看到了预料之中的输出

00:01:17.924 --> 00:01:20.640
这张图像的确是个数组 其形状包含了三个值

00:01:20.640 --> 00:01:24.200
代表了图像数组的不同维度

00:01:24.200 --> 00:01:26.742
第一个是高度 514 像素

00:01:26.742 --> 00:01:28.808
然后是宽度 816

00:01:28.808 --> 00:01:32.459
最后是颜色分量的数目 这里有三种

00:01:32.459 --> 00:01:35.869
即红色、绿色和蓝色的值

00:01:35.870 --> 00:01:38.745
接着 用 pyplot 把图像显示出来

00:01:38.745 --> 00:01:40.915
可图像看起来怪怪的

00:01:40.915 --> 00:01:44.095
背景是红色的 而不是我们预料的蓝色

00:01:44.094 --> 00:01:45.700
这是为什么呢？

00:01:45.700 --> 00:01:50.189
这是因为 OpenCV 会把彩色图像读取成 BGR (蓝、绿、红) 图像

00:01:50.189 --> 00:01:52.965
而不是 RGB 图像

00:01:52.965 --> 00:01:57.945
所以红色和蓝色掉转过来了 而 pyplot 呈现的就是调转后的图像

00:01:57.944 --> 00:02:01.579
至于 OpenCV 这么读取的原因 请见文本说明

00:02:01.579 --> 00:02:04.739
但我会把这张图从 BGR 转为 RGB

00:02:04.739 --> 00:02:09.224
这样才方便展示 以后还有很多例子我也会这么做

00:02:09.224 --> 00:02:11.849
所以在显示图像之前 先复制原始图像

00:02:11.849 --> 00:02:17.079
用 OpenCV 将颜色从 BGR 改为 RGB

00:02:17.080 --> 00:02:20.955
处理图像时 顺手备份是个好习惯

00:02:20.955 --> 00:02:26.087
这样一来 无论你对副本进行什么变换 原图都不会受到影响

00:02:26.086 --> 00:02:28.754
这样要撤回操作或尝试新方法都容易许多

00:02:28.754 --> 00:02:31.634
我把这个副本命名为 image_copy

00:02:31.634 --> 00:02:33.659
然后

00:02:33.659 --> 00:02:38.520
我们就可以用 OpenCV 的函数 cvtColor 对副本进行颜色转换了

00:02:38.520 --> 00:02:40.080
该函数需要输入的参数有源图像

00:02:40.080 --> 00:02:44.414
和颜色转换代码 这里的代码即 BGR2RGB

00:02:44.413 --> 00:02:47.129
然后输出我们想要的图像

00:02:47.129 --> 00:02:52.074
这回如果把图像副本绘制出来 我们就能如愿以偿地看到蓝幕背景了

00:02:52.074 --> 00:02:53.519
刚才我放慢速度给大家演示了图像读取和复制

00:02:53.520 --> 00:02:56.505
也给大家看了代码

00:02:56.504 --> 00:02:58.370
因为这些是常用步骤

00:02:58.370 --> 00:03:02.219
现在我们开始来讲蓝幕颜色阀值的代码

00:03:02.219 --> 00:03:04.264
要创建颜色阀值

00:03:04.264 --> 00:03:09.024
首先得定义要分离的颜色的上下限 也就是蓝色的上下限

00:03:09.025 --> 00:03:11.370
我想用这些值

00:03:11.370 --> 00:03:15.814
选出包含这个颜色值范围的蓝幕区域 然后将该区域删除

00:03:15.814 --> 00:03:20.039
我要定义下限 下限涉及的红、

00:03:20.039 --> 00:03:24.254
绿和蓝三者的值就是仍能视为蓝幕背景的最小值

00:03:24.254 --> 00:03:26.715
所以这会是个包含三个值的数组

00:03:26.715 --> 00:03:33.060
我把红色和绿色的值设为 0 意味着就算没有红色和绿色也行

00:03:33.060 --> 00:03:36.210
但蓝色就算是最小值也要设得高些

00:03:36.210 --> 00:03:37.965
虽然不至于要 255 那么高

00:03:37.965 --> 00:03:40.085
但也得设在 230 左右吧

00:03:40.085 --> 00:03:42.870
上限也是一个原理

00:03:42.870 --> 00:03:45.314
这次允许红色和绿色的值多一点

00:03:45.314 --> 00:03:50.409
就设两者都为 50  吧 然后把蓝色的最大值设为 255

00:03:50.409 --> 00:03:54.719
任何在这个上下限范围里的值都会是明显的蓝色

00:03:54.719 --> 00:03:57.120
不过我只是估算了一下

00:03:57.120 --> 00:03:59.955
所以如果在这个范围里找不到我要的蓝幕区域

00:03:59.955 --> 00:04:01.859
那我就会回到这一步 修改这些值

00:04:01.859 --> 00:04:06.865
接下来 我要用刚才创建的颜色阀值来创建图像掩膜

00:04:06.865 --> 00:04:09.360
掩膜常用于

00:04:09.360 --> 00:04:12.975
把我们选定的感兴趣区域分离出来 以便进行操作

00:04:12.974 --> 00:04:19.254
我们可以用 OpenCV 的函数 inRange 在蓝色区域上覆盖一层掩膜

00:04:19.254 --> 00:04:21.029
该函数需要输入的参数有

00:04:21.029 --> 00:04:24.809
图像、颜色的上限和下限

00:04:24.810 --> 00:04:27.555
定义掩膜时 函数会确认各图像像素的颜色值

00:04:27.555 --> 00:04:31.300
是否在颜色阀值的范围内

00:04:31.300 --> 00:04:32.985
如果在

00:04:32.985 --> 00:04:35.420
那掩膜就会把像素显示出来

00:04:35.420 --> 00:04:38.814
如果不在 掩膜就会遮住像素 把像素变成黑色

00:04:38.814 --> 00:04:43.589
事实上 我们可以跟绘制图像一样 将掩膜可视化

00:04:43.589 --> 00:04:45.989
白色区域是图像可以透过掩膜显示出来的部分

00:04:45.990 --> 00:04:48.930
黑色则是会被掩膜遮住的部分

00:04:48.930 --> 00:04:51.629
从值上看 我们可以把这个掩膜

00:04:51.629 --> 00:04:54.949
看成一个二维网格 其维度和我们的图像相同

00:04:54.949 --> 00:04:58.485
高度为 514 像素 宽度为 816

00:04:58.485 --> 00:05:05.302
掩膜的每个坐标都有一个代表白色的值 255 或代表黑色的值 0

00:05:05.302 --> 00:05:07.540
有点像灰度图像

00:05:07.540 --> 00:05:11.129
观察这个掩膜 我们可以发现它有个区域是白色的

00:05:11.129 --> 00:05:15.300
这是蓝幕背景所在之处 还有个区域是黑色的 这是披萨所在之处

00:05:15.300 --> 00:05:17.520
所以首先

00:05:17.519 --> 00:05:20.935
我们要把披萨显示出来 同时遮住蓝幕背景

00:05:20.935 --> 00:05:24.089
首先 给图像添加掩膜 我再复制一次图像

00:05:24.089 --> 00:05:27.449
将其命名为 masked image 意思是颜色转换后的掩膜副本图像

00:05:27.449 --> 00:05:30.189
如果我稍后想修改掩膜 这样会方便些

00:05:30.189 --> 00:05:35.160
要选择蓝幕区域 一个办法是

00:05:35.160 --> 00:05:40.905
提取图像与掩膜白色区域重叠的部分 或者说是与掩膜非黑区域重叠的部分

00:05:40.904 --> 00:05:43.139
也就是说 我们要选择的那部分图像

00:05:43.139 --> 00:05:45.838
是掩膜不等于 0 的区域

00:05:45.838 --> 00:05:49.134
所以要用 “！=” 这个布尔操作符

00:05:49.134 --> 00:05:51.779
其中感叹号的意思是 “非”

00:05:51.779 --> 00:05:56.294
要把这个背景遮住 我们得把这些像素设为黑色

00:05:56.295 --> 00:06:00.765
在 RGB 里 黑色就是三个颜色值都为 0

00:06:00.764 --> 00:06:03.449
把图像显示出来 我们应该就能看到

00:06:03.449 --> 00:06:06.464
披萨是唯一显示出来的部分

00:06:06.464 --> 00:06:09.060
而蓝幕背景已经消失了

00:06:09.060 --> 00:06:13.495
甚至我还可以修改颜色阀值 把剩下的这些小点去掉

00:06:13.495 --> 00:06:20.370
我试着将绿色的最大值调到 70 将蓝色的最小值调到 220

00:06:20.370 --> 00:06:22.629
这样能获取的蓝色范围应该就更广了

00:06:22.629 --> 00:06:26.029
再次运行掩膜和图像显示代码

00:06:26.029 --> 00:06:28.229
效果更好了

00:06:28.230 --> 00:06:32.790
现在就剩最后一步了 也即给这张图像添加背景

00:06:32.790 --> 00:06:37.050
操作很类似 所以我就快速过一遍了

00:06:37.050 --> 00:06:41.530
首先 读取一张外太空的图像 将其转为 RGB 颜色

00:06:41.529 --> 00:06:45.329
裁剪图像 使其与披萨图大小相同

00:06:45.329 --> 00:06:47.818
也即 514 乘 816 像素

00:06:47.819 --> 00:06:50.845
将其命名为 crop_background

00:06:50.845 --> 00:06:52.485
然后应用掩膜

00:06:52.485 --> 00:06:54.855
这次要用的掩膜完全相反

00:06:54.855 --> 00:06:58.730
也就是说得让背景显示出来 而不显示披萨所在的区域

00:06:58.730 --> 00:07:02.040
如果重新回来看这个掩膜 我们就能发现

00:07:02.040 --> 00:07:06.050
这次我遮住的是图像背景 也就是掩膜的值等于 0 的部分

00:07:06.050 --> 00:07:09.824
所以写 mask == 0

00:07:09.824 --> 00:07:12.164
为了确认掩膜是否正确

00:07:12.165 --> 00:07:17.265
我把操作后的图像绘制出来 于是看到了没有披萨的背景

00:07:17.264 --> 00:07:20.818
确认完毕 最后只需将两张图像叠放到一起

00:07:20.819 --> 00:07:25.139
因为黑色区域的像素颜色值等于 0

00:07:25.139 --> 00:07:27.264
所以我们只需进行简单的加法

00:07:27.264 --> 00:07:33.419
绘制出整张图像 披萨就漂浮在天空里了 就是这样

00:07:33.420 --> 00:07:36.925
你可以在文本里查看函数注释

00:07:36.925 --> 00:07:41.000
接下来你需要做些练习 动手编写自己的颜色阀值代码

