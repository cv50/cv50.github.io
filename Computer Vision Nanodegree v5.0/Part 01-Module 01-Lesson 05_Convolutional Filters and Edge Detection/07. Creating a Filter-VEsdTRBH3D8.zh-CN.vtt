WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.250
现在我们来讲怎么创建高通过滤器

00:00:04.250 --> 00:00:07.820
首先我要讲怎么自定义核

00:00:07.820 --> 00:00:12.490
接着 我们会用 OpenCV 的函数来创建常用的过滤器

00:00:12.490 --> 00:00:14.515
这是一张建筑图

00:00:14.515 --> 00:00:17.199
这栋建筑其实是旧金山市政大厅

00:00:17.199 --> 00:00:22.149
我读取了图像 照常复制了 RGB 副本 以便处理

00:00:22.149 --> 00:00:25.274
首先 把这张图转换为灰度图像

00:00:25.274 --> 00:00:29.279
用的函数是 cvtcolor 代码是 RGB2GRAY

00:00:29.280 --> 00:00:34.070
这样一来 过滤器就能检测到图像强度的变化了

00:00:34.070 --> 00:00:37.643
接着 自定义边缘检测过滤器

00:00:37.643 --> 00:00:42.719
我想创建过滤器来检测垂直边缘 但不检测水平边缘

00:00:42.719 --> 00:00:46.560
因此 我要创建一个三乘三矩阵 矩阵使用的值

00:00:46.560 --> 00:00:51.920
要能计算图像这部分像素区域左右两边的差异

00:00:51.920 --> 00:00:55.160
首先 创建一个三乘三的空核

00:00:55.159 --> 00:00:57.929
在左边放入负值

00:00:57.929 --> 00:00:59.520
使角落的权重

00:00:59.520 --> 00:01:02.325
小于与中心像素相邻的边缘

00:01:02.325 --> 00:01:08.484
中间一栏填 0 右边则填正值

00:01:08.484 --> 00:01:12.750
一旦以某个图像像素作为这个核的中心 核就会开始计算

00:01:12.750 --> 00:01:17.995
左右两边的像素差 从而检测出垂直边缘

00:01:17.995 --> 00:01:22.150
这其实是种很常见的过滤器 叫做 Sobel 过滤器

00:01:22.150 --> 00:01:28.755
Sobel 过滤器可分别检测 x 和 y 轴方向的强度突变

00:01:28.754 --> 00:01:32.849
这个过滤器会对 x 轴方向的空间强度梯度进行估算

00:01:32.849 --> 00:01:37.530
也就是对强度变化进行估算 我就将其命名为 sobel_x 好了

00:01:37.530 --> 00:01:41.689
然后 将这个过滤器和输入图像进行卷积

00:01:41.689 --> 00:01:45.370
使用 OpenCV 的函数 filter2D

00:01:45.370 --> 00:01:47.840
这个函数的参数有 输入图像、

00:01:47.840 --> 00:01:49.760
输出图像的类型

00:01:49.760 --> 00:01:54.052
-1 指的是输出与输入类型一致

00:01:54.052 --> 00:01:56.190
以及我们刚创建的核

00:01:56.189 --> 00:02:00.789
即 sobel_x 函数会生成滤波后的图像 filtered image

00:02:00.790 --> 00:02:03.829
把图像绘制出来 看看效果

00:02:03.828 --> 00:02:05.884
基本符合我的预期

00:02:05.885 --> 00:02:09.599
所有垂直边缘都得到了高亮

00:02:09.599 --> 00:02:14.629
这类过滤器能帮我检测建筑及其周边结构的垂直边缘

00:02:14.629 --> 00:02:17.069
最后一步 也是计算机视觉相当实用的一步

00:02:17.069 --> 00:02:20.840
就是将图像转换为二值图像

00:02:20.840 --> 00:02:22.469
也就是说 将其转换成

00:02:22.469 --> 00:02:27.629
纯粹的黑白图像 强度最高的边缘就会十分显眼了

00:02:27.629 --> 00:02:31.564
因此 使用 OpenCV 的函数 threshold

00:02:31.564 --> 00:02:35.490
该函数的参数有 滤波后想施加阀值限制的图像

00:02:35.490 --> 00:02:38.280
一个供像素值通过的下限

00:02:38.280 --> 00:02:43.055
我就设得相对高些 设为 100 吧

00:02:43.055 --> 00:02:48.230
还有像素值上限 我设为白色 也就是 255

00:02:48.230 --> 00:02:50.340
最后是阀值类型

00:02:50.340 --> 00:02:53.819
设为二进制阀值 将图像绘制出来

00:02:53.819 --> 00:02:57.719
我们可以清楚地看到较强的边缘

00:02:57.719 --> 00:03:02.039
如果将阀值降低到 50 再运行这段代码

00:03:02.039 --> 00:03:04.590
我就能检测到更多边缘

00:03:04.590 --> 00:03:08.164
事实上 检测到的边缘太多了 反而不好

00:03:08.164 --> 00:03:11.340
所以还是将阀值设回 100 吧

00:03:11.340 --> 00:03:13.740
这里我放大了图像 以便观察第一张图像 也即滤波后的图像

00:03:13.740 --> 00:03:17.439
和第二张图像 也即二值图像之间的区别

00:03:17.439 --> 00:03:19.800
我们会发现 除了建筑、

00:03:19.800 --> 00:03:22.204
窗户和其它结构的边缘外

00:03:22.204 --> 00:03:25.110
还检测出了许多小一些的边缘

00:03:25.110 --> 00:03:27.265
比如草地上的这些点

00:03:27.264 --> 00:03:31.864
这些点并不能提供任何建筑或景物的额外信息

00:03:31.865 --> 00:03:34.080
不过是噪声而已

00:03:34.080 --> 00:03:37.455
常见的噪声有噪点和模糊的细节

00:03:37.455 --> 00:03:39.465
检测这类边缘时

00:03:39.465 --> 00:03:43.094
高通过滤器会强化图像里的这些噪声

00:03:43.094 --> 00:03:45.629
所以应用这类过滤器要十分小心

00:03:45.629 --> 00:03:51.759
通常我们需要增加一步操作 才能确保噪声得不到强化

00:03:51.759 --> 00:03:54.269
很快我们就要来讲低通过滤器了

00:03:54.270 --> 00:03:56.969
我们要用低通过滤器来对图像进行模糊处理 以便降噪

00:03:56.969 --> 00:03:59.039
在像这样使用高通过滤器之前

00:03:59.039 --> 00:04:02.474
我们都会先降噪

00:04:02.474 --> 00:04:04.620
等你再做几个高通过滤器边缘检测的练习后

00:04:04.620 --> 00:04:08.159
我们就来学习低通过滤器

