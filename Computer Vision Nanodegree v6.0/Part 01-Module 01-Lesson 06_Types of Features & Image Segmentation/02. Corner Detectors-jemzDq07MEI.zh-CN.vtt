WEBVTT
Kind: captions
Language: zh-CN

00:00:00.470 --> 00:00:03.089
在创建边缘检测器时

00:00:03.089 --> 00:00:06.705
我们会观察相邻像素间的强度差异

00:00:06.705 --> 00:00:10.019
如果强度变化很大而且很突兀 那我们就会检测到边缘

00:00:10.019 --> 00:00:13.154
不管变化的方向是上还是下

00:00:13.154 --> 00:00:15.699
是左还是右 还是走斜线 都是如此

00:00:15.699 --> 00:00:19.589
之前我们说过 图像强度变化往往也称为

00:00:19.589 --> 00:00:22.199
图像梯度

00:00:22.199 --> 00:00:25.239
要检测角点 我们也可以靠这类梯度测量法来进行

00:00:25.239 --> 00:00:27.599
我们知道角点就是

00:00:27.600 --> 00:00:31.530
两个边缘的相交点 我们可以借助窗口来检测角点

00:00:31.530 --> 00:00:34.050
所谓窗口 一般指的是一个正方形区域 其中包含了一组像素

00:00:34.049 --> 00:00:38.329
通过该区域 我们可以观察各方向 找出高梯度的部分

00:00:38.329 --> 00:00:40.170
每个方向的梯度测量

00:00:40.170 --> 00:00:44.310
都会有一个幅值 即梯度强度的度量值

00:00:44.310 --> 00:00:48.115
和表示强度变化的方向

00:00:48.115 --> 00:00:51.975
这些值都能用 Sobel 算子计算出来

00:00:51.975 --> 00:00:54.899
Sobel 算子会分别取 x 和 y 方向的

00:00:54.899 --> 00:00:58.625
强度变化或图像梯度

00:00:58.625 --> 00:01:01.875
这里我绘制出了山峰图像的这两个梯度

00:01:01.875 --> 00:01:05.325
分别称之为 Gx 和 Gy 其中 G 是梯度的英文首字母

00:01:05.325 --> 00:01:09.000
你可能会发现 这两张图看起来和之前的卷积核有点不一样

00:01:09.000 --> 00:01:13.120
因为它们还没有转为二进制阀值图像

00:01:13.120 --> 00:01:14.805
但这里我们不需要转化

00:01:14.805 --> 00:01:16.860
然后我们需要计算出这两个方向总梯度的

00:01:16.859 --> 00:01:19.859
幅值和方向

00:01:19.859 --> 00:01:23.879
因此 我们需要将这些值从图像空间的 xy 坐标系

00:01:23.879 --> 00:01:28.914
转换成极坐标系 以 ρ 表示幅值 θ 表示方向

00:01:28.915 --> 00:01:31.605
这看起来可能有点像霍夫变换

00:01:31.605 --> 00:01:33.353
在任意像素位置中

00:01:33.353 --> 00:01:38.304
你可以把 Gx 和 Gy 想象成梯度三角形两边的长

00:01:38.304 --> 00:01:43.000
Gx 是底边的长 Gy 则是右边的长

00:01:43.000 --> 00:01:47.129
所以梯度的总幅值 ρ 就是三角形的斜线

00:01:47.129 --> 00:01:51.238
也就是这两个梯度和的平方根

00:01:51.239 --> 00:01:54.120
而梯度方向 θ

00:01:54.120 --> 00:01:57.900
则是 Gy 除以 Gx 的正切的倒数

00:01:57.900 --> 00:02:01.995
计算所得的梯度幅值图像看起来应该像这样

00:02:01.995 --> 00:02:05.930
最大的梯度对应最明亮的线条

00:02:05.930 --> 00:02:10.230
许多角点检测器会取一个窗口

00:02:10.229 --> 00:02:15.465
并在梯度图像不同区域里上下左右移动这个窗口

00:02:15.465 --> 00:02:18.840
如果我们移动的幅度很小 一旦遇到角点

00:02:18.840 --> 00:02:22.050
窗口就会发现刚才计算出来的梯度方向和幅值有突变

00:02:22.050 --> 00:02:26.910
因而识别出角点的存在

00:02:26.909 --> 00:02:28.530
我来详细讲一下

00:02:28.530 --> 00:02:32.039
如何根据这些知识 编写一个简单的角点检测器

00:02:32.039 --> 00:02:34.769
根据移动窗口找到的最大梯度变化位置

00:02:34.770 --> 00:02:38.140
来找出角点

00:02:38.139 --> 00:02:41.354
这里我读取了张以一定角度拍摄的棋盘图

00:02:41.354 --> 00:02:45.244
跟往常一样 复制图像 将其转为 RGB 颜色空间

00:02:45.245 --> 00:02:48.000
之所以选择这张图 是因为我们可以轻易地观察

00:02:48.000 --> 00:02:51.014
角点检测器实现的效果

00:02:51.014 --> 00:02:54.275
角点检测靠的是强度变化

00:02:54.275 --> 00:02:56.890
所以先把图像转为灰度图像

00:02:56.889 --> 00:02:59.339
然后将值转化为浮点型

00:02:59.340 --> 00:03:01.795
以便 Hrarris 角点检测器使用

00:03:01.794 --> 00:03:04.034
接着创建角点检测器 Harris

00:03:04.034 --> 00:03:08.905
我用 OpenCV 的函数 cornerHarris 来创建

00:03:08.905 --> 00:03:12.270
该函数需要输入的参数有灰度浮点值、

00:03:12.270 --> 00:03:16.010
以及检测潜在角点所需观察的相邻像素大小

00:03:16.009 --> 00:03:18.449
2 表示 2 乘 2 像素方块

00:03:18.449 --> 00:03:21.119
由于在这个例子中 角点很明显

00:03:21.120 --> 00:03:23.700
所以这样的小窗口就够用了

00:03:23.699 --> 00:03:26.353
然后输入 Sobel 算子的大小

00:03:26.354 --> 00:03:29.210
3 也就是典型的核大小

00:03:29.210 --> 00:03:33.810
最后输入一个常数 以便确定哪些点会被视为角点

00:03:33.810 --> 00:03:36.854
通常设为 0.04

00:03:36.854 --> 00:03:40.769
如果这个常数设得稍微小一些 那检测出来的角点就会多一些

00:03:40.770 --> 00:03:46.439
我把函数的输出图像命名为 dst 也就是目标的英文缩写

00:03:46.439 --> 00:03:48.375
这个图像会把角点标亮

00:03:48.375 --> 00:03:51.930
非角点则会标为较暗的像素

00:03:51.930 --> 00:03:53.745
把图像绘制出来 看看效果

00:03:53.745 --> 00:03:58.080
实际上我们很难看到这张图里标亮的角点

00:03:58.080 --> 00:04:00.765
所以我要再加一步操作来处理这些角点

00:04:00.764 --> 00:04:02.639
这一步叫角点膨胀

00:04:02.639 --> 00:04:08.879
因此 使用 OpenCV 的函数 dilate 将其应用到检测出来的角点上

00:04:08.879 --> 00:04:12.479
在计算机视觉里 膨胀会放大明亮的区域

00:04:12.479 --> 00:04:16.663
或是位于前景的区域 比如这些角点 以便我们更清楚地观察它们

00:04:16.663 --> 00:04:19.219
显示膨胀结果

00:04:19.220 --> 00:04:23.450
现在你就可以清楚地看到这些角点了 就是图像上这些亮点

00:04:23.449 --> 00:04:27.779
最后几步就是选出最明亮的角点 将其显示出来

00:04:27.779 --> 00:04:32.654
要选出最明亮的角点 我得定义一个阀值 以便角点通过

00:04:32.654 --> 00:04:35.649
阀值的设置取决于图像

00:04:35.649 --> 00:04:38.064
但这里我要设一个较低的阀值

00:04:38.064 --> 00:04:41.685
也就是至少为最大角点检测值的十分之一

00:04:41.685 --> 00:04:44.139
接下来 编写代码以显示角点

00:04:44.139 --> 00:04:47.596
首先 创建图像副本以便绘制角点

00:04:47.596 --> 00:04:51.224
如果角点大于我们定义的阀值

00:04:51.225 --> 00:04:52.900
那就把它绘制在副本上

00:04:52.899 --> 00:04:55.139
这里我用了 OpenCV 的函数

00:04:55.139 --> 00:04:58.634
在图像副本上用小绿圈画出强角点

00:04:58.634 --> 00:05:00.899
将结果显示出来

00:05:00.899 --> 00:05:05.589
如果把结果放大 你就可以看到多数角点都被检测出来了

00:05:05.589 --> 00:05:08.000
但在这里和这里 实际上少了几个角点

00:05:08.000 --> 00:05:11.009
所以把阀值调低试试

00:05:11.009 --> 00:05:17.139
把阀值减少至角点最大值的 1% 再次将结果绘制出来

00:05:17.139 --> 00:05:20.620
现在你就可以看到 棋盘上所有角点都被检测出来了

00:05:20.620 --> 00:05:24.350
观察这些绿圈出现的位置 你会发现一些很有趣的事情

00:05:24.350 --> 00:05:26.870
比如棋盘右下角没有检测出角点

00:05:26.870 --> 00:05:31.185
因为这里的强度没有变化

00:05:31.185 --> 00:05:33.764
棋盘和背景都是白色的

00:05:33.764 --> 00:05:37.473
但在黑白相交处我们就检测到了角点

00:05:37.473 --> 00:05:41.060
试想一下 我们可以用这些角点来求取

00:05:41.060 --> 00:05:43.280
棋盘的面积

00:05:43.279 --> 00:05:47.049
或取部分角点来进行视角变换

00:05:47.050 --> 00:05:52.160
由此可见 仅仅是角点 就对多种分析和几何变换大有帮助了

