WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.839
ORB 算法的第二步是

00:00:03.839 --> 00:00:06.060
将第一个算法发现的关键点变成特征向量

00:00:06.059 --> 00:00:09.464
这些特征向量可以共同表示一个对象

00:00:09.464 --> 00:00:11.219
要创建特征向量

00:00:11.220 --> 00:00:13.304
ORB 会用到 BRIEF 算法

00:00:13.304 --> 00:00:17.640
BRIEF 是 Binary Robust Independent Elementary Features 的简称

00:00:17.640 --> 00:00:21.510
它的作用是根据一组关键点创建二元特征向量

00:00:21.510 --> 00:00:24.135
正如在简介视频中看到的

00:00:24.135 --> 00:00:25.679
二元特征向量

00:00:25.679 --> 00:00:27.809
又称为二元描述符

00:00:27.809 --> 00:00:31.484
是仅包含 1 和 0 的特征向量

00:00:31.484 --> 00:00:35.490
在 BRIEF 中 每个关键点由一个二元特征向量描述

00:00:35.490 --> 00:00:40.365
该向量有 128-512 位字符串 其中仅包含 1 和 0

00:00:40.365 --> 00:00:43.554
提醒下 位是二进制位的简称

00:00:43.554 --> 00:00:46.695
1 位只能存储一个二进制值

00:00:46.695 --> 00:00:48.255
要么 1 要么是 0

00:00:48.255 --> 00:00:50.895
位字符串是一组位

00:00:50.895 --> 00:00:53.910
这些是位字符串示例

00:00:53.909 --> 00:00:57.719
第一个是 1 位字符串 因此只存储 1 位

00:00:57.719 --> 00:01:02.070
第二个是 2 位字符串 因此可以存储 2 个二进制位

00:01:02.070 --> 00:01:04.469
在此示例中 它存储的是 0 和 1

00:01:04.469 --> 00:01:09.510
同样 第三个是 3 位字符串 因此可以存储 3 个位 以此类推

00:01:09.510 --> 00:01:12.609
计算机运行的是二进制或机器代码

00:01:12.609 --> 00:01:16.109
因此使用二元特征向量的一大优势是

00:01:16.109 --> 00:01:20.280
可以非常高效地存储在内存中 并且可以快速计算

00:01:20.280 --> 00:01:23.070
这些特性不仅使 BRIEF 速度非常快

00:01:23.069 --> 00:01:25.379
速度对实时应用来说极为关键

00:01:25.379 --> 00:01:27.959
而且使 BRIEF 能够在计算资源

00:01:27.959 --> 00:01:31.649
非常有限的设备（例如智能手机）上运行

00:01:31.650 --> 00:01:35.655
BRIEF 如何为每个点创建这些二元描述符？

00:01:35.655 --> 00:01:38.969
BRIEF 算法首先利用高斯核

00:01:38.969 --> 00:01:41.174
对给定图像进行平滑处理

00:01:41.174 --> 00:01:44.564
以防描述符对高频噪点过于敏感

00:01:44.564 --> 00:01:48.060
接着 对于给定关键点 例如猫爪上的这个点

00:01:48.060 --> 00:01:50.460
BRIEF 从该关键点周围界定好的邻域内

00:01:50.459 --> 00:01:53.099
随机选择一对像素

00:01:53.099 --> 00:01:56.549
关键点周围的邻域称为 Patch

00:01:56.549 --> 00:01:59.159
它是一个具有特定像素宽度和高度的正方形

00:01:59.159 --> 00:02:01.590
这里显示的随机对中的第一个像素

00:02:01.590 --> 00:02:03.299
是一个蓝色正方形

00:02:03.299 --> 00:02:06.359
它是从以关键点为中心的高斯分布中抽取的一个像素

00:02:06.359 --> 00:02:09.629
标准偏差或分散趋势为 σ

00:02:09.629 --> 00:02:12.449
这里显示为黄色正方形的像素

00:02:12.449 --> 00:02:14.109
是随机对中的第二个像素

00:02:14.110 --> 00:02:16.860
它是从以该第一个像素为中心的高斯分布中抽取的像素

00:02:16.860 --> 00:02:21.450
标准偏差为 σ/2

00:02:21.449 --> 00:02:23.879
经验表明这种高斯选择

00:02:23.879 --> 00:02:26.745
提高了特征匹配率

00:02:26.745 --> 00:02:31.170
BRIEF 然后开始为关键点构建二元描述符

00:02:31.169 --> 00:02:32.864
方法是如下所示地比较这两个像素的亮度

00:02:32.865 --> 00:02:36.200
如果第一个像素比第二个亮

00:02:36.199 --> 00:02:40.049
则为描述符中的相应位分配值 1

00:02:40.050 --> 00:02:42.765
否则分配值 0

00:02:42.764 --> 00:02:44.789
在这个示例中

00:02:44.789 --> 00:02:47.009
第二个像素比第一个亮

00:02:47.009 --> 00:02:51.120
因此我们为特征向量的第一个位分配值 0

00:02:51.120 --> 00:02:53.879
特征向量的第一个位对应的是

00:02:53.879 --> 00:02:57.254
这个关键点的第一个随机点对

00:02:57.254 --> 00:02:59.460
现在 BRIEF 针对同一关键点

00:02:59.460 --> 00:03:02.159
选择新的随机像素对

00:03:02.159 --> 00:03:07.049
比较它们的亮度并为特征向量中的下个位分配 1 或 0

00:03:07.050 --> 00:03:10.965
在我们的示例中 我们看到现在第一个像素比第二个亮

00:03:10.965 --> 00:03:15.090
因此 为特征向量中的第二个位分配值 1

00:03:15.090 --> 00:03:17.759
对于 256 位向量

00:03:17.759 --> 00:03:20.759
BRIEF 会针对同一关键点重复这一流程 256 次

00:03:20.759 --> 00:03:24.764
然后转到下个关键点

00:03:24.764 --> 00:03:28.829
接着将 256 个像素亮度比较结果

00:03:28.830 --> 00:03:32.835
放入该关键点的二元特征向量中

00:03:32.835 --> 00:03:36.840
BRIEF 像这样为图像中的每个关键点创建一个向量

00:03:36.840 --> 00:03:39.780
现在 你已经知道 BRIEF 如何为

00:03:39.780 --> 00:03:42.390
由 FAST 发现的关键点构建特征向量

00:03:42.389 --> 00:03:45.029
接下来 我们将了解 ORB 如何利用这些技巧

00:03:45.030 --> 00:03:49.039
创建不受图像旋转 缩放和噪点影响的向量

