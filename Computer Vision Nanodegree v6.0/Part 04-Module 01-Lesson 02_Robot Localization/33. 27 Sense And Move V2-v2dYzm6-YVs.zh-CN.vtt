WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.089
哇 你基本上编写了

00:00:03.089 --> 00:00:07.620
Google 无人驾驶汽车的定位功能 虽然你可能没有意识到

00:00:07.620 --> 00:00:09.900
总结下我们学习的知识

00:00:09.900 --> 00:00:11.815
我们讨论了测量更新

00:00:11.814 --> 00:00:13.320
讨论了动作

00:00:13.320 --> 00:00:15.849
编写了两个部分 感知和移动

00:00:15.849 --> 00:00:19.980
定位就是感知和移动的不断重复

00:00:19.980 --> 00:00:23.785
初始信念被放入这个循环中

00:00:23.785 --> 00:00:26.530
如果先感知 转到左侧

00:00:26.530 --> 00:00:31.155
然后定位不断循环 移动感知

00:00:31.155 --> 00:00:33.125
移动感知移动感知

00:00:33.125 --> 00:00:35.070
移动感知移动感知 一直循环

00:00:35.070 --> 00:00:36.975
每次机器人移动时

00:00:36.975 --> 00:00:39.274
都会丢失位置信息

00:00:39.274 --> 00:00:42.049
因为机器人运动不准确

00:00:42.049 --> 00:00:44.774
每次感知时 都会获得信息

00:00:44.774 --> 00:00:47.519
这就体现了一个事实

00:00:47.520 --> 00:00:50.740
移动之后 概率分布更扁平分散

00:00:50.740 --> 00:00:54.635
感知后 更加聚焦

00:00:54.634 --> 00:00:56.464
实际上 提示下

00:00:56.465 --> 00:00:59.390
有一个信息衡量方式 叫做熵

00:00:59.390 --> 00:01:02.355
有很多种写法 这是其中之一

00:01:02.354 --> 00:01:07.289
它是每个网格单元的概率预期对数似然率

00:01:07.290 --> 00:01:08.820
我不再详细讲解

00:01:08.819 --> 00:01:12.314
熵用来衡量分布的信息

00:01:12.314 --> 00:01:14.920
可以表明 更新步骤（动作步骤）

00:01:14.920 --> 00:01:17.905
使熵减小

00:01:17.905 --> 00:01:20.439
而测量步骤使熵增大

00:01:20.439 --> 00:01:22.709
我们不断丢失和获得信息

00:01:22.709 --> 00:01:25.824
我在代码中实现这一过程

00:01:25.825 --> 00:01:29.365
除了之前的两个测量结果 red 和 green 之外

00:01:29.364 --> 00:01:31.024
将提供两个动作 1 和 1

00:01:31.025 --> 00:01:34.050
表示往右移动 再往右移动

00:01:34.049 --> 00:01:39.920
如果首先感知到红色 然后往右移动 1 个单位

00:01:39.920 --> 00:01:42.325
感知绿色 再往右移动

00:01:42.325 --> 00:01:44.609
你能计算后验分布吗？

00:01:44.609 --> 00:01:48.519
我们从均匀先验分布开始

